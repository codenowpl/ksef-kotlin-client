/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package pl.com.codenow.ksefclient.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import pl.com.codenow.ksefclient.models.CertificateEnrollmentDataResponse
import pl.com.codenow.ksefclient.models.CertificateEnrollmentStatusResponse
import pl.com.codenow.ksefclient.models.CertificateLimitsResponse
import pl.com.codenow.ksefclient.models.EnrollCertificateRequest
import pl.com.codenow.ksefclient.models.EnrollCertificateResponse
import pl.com.codenow.ksefclient.models.ExceptionResponse
import pl.com.codenow.ksefclient.models.QueryCertificatesRequest
import pl.com.codenow.ksefclient.models.QueryCertificatesResponse
import pl.com.codenow.ksefclient.models.RetrieveCertificatesRequest
import pl.com.codenow.ksefclient.models.RetrieveCertificatesResponse
import pl.com.codenow.ksefclient.models.RevokeCertificateRequest

import com.squareup.moshi.Json

import pl.com.codenow.ksefclient.infrastructure.ApiClient
import pl.com.codenow.ksefclient.infrastructure.ApiResponse
import pl.com.codenow.ksefclient.infrastructure.ClientException
import pl.com.codenow.ksefclient.infrastructure.ClientError
import pl.com.codenow.ksefclient.infrastructure.ServerException
import pl.com.codenow.ksefclient.infrastructure.ServerError
import pl.com.codenow.ksefclient.infrastructure.MultiValueMap
import pl.com.codenow.ksefclient.infrastructure.PartConfig
import pl.com.codenow.ksefclient.infrastructure.RequestConfig
import pl.com.codenow.ksefclient.infrastructure.RequestMethod
import pl.com.codenow.ksefclient.infrastructure.ResponseType
import pl.com.codenow.ksefclient.infrastructure.Success
import pl.com.codenow.ksefclient.infrastructure.toMultiValue

class CertyfikatyKsefApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Unieważnienie certyfikatu
     * Unieważnia certyfikat o podanym numerze seryjnym.
     * @param certificateSerialNumber Numer seryjny certyfikatu (w formacie szesnastkowym).
     * @param revokeCertificateRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesCertificateSerialNumberRevokePost(certificateSerialNumber: kotlin.String, revokeCertificateRequest: RevokeCertificateRequest? = null) : Unit {
        val localVarResponse = apiV2CertificatesCertificateSerialNumberRevokePostWithHttpInfo(certificateSerialNumber = certificateSerialNumber, revokeCertificateRequest = revokeCertificateRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unieważnienie certyfikatu
     * Unieważnia certyfikat o podanym numerze seryjnym.
     * @param certificateSerialNumber Numer seryjny certyfikatu (w formacie szesnastkowym).
     * @param revokeCertificateRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesCertificateSerialNumberRevokePostWithHttpInfo(certificateSerialNumber: kotlin.String, revokeCertificateRequest: RevokeCertificateRequest?) : ApiResponse<Unit?> {
        val localVariableConfig = apiV2CertificatesCertificateSerialNumberRevokePostRequestConfig(certificateSerialNumber = certificateSerialNumber, revokeCertificateRequest = revokeCertificateRequest)

        return request<RevokeCertificateRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesCertificateSerialNumberRevokePost
     *
     * @param certificateSerialNumber Numer seryjny certyfikatu (w formacie szesnastkowym).
     * @param revokeCertificateRequest  (optional)
     * @return RequestConfig
     */
    fun apiV2CertificatesCertificateSerialNumberRevokePostRequestConfig(certificateSerialNumber: kotlin.String, revokeCertificateRequest: RevokeCertificateRequest?) : RequestConfig<RevokeCertificateRequest> {
        val localVariableBody = revokeCertificateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/certificates/{certificateSerialNumber}/revoke".replace("{"+"certificateSerialNumber"+"}", encodeURIComponent(certificateSerialNumber.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Pobranie danych do wniosku certyfikacyjnego
     * Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.  Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują podmiot, który składa wniosek o certyfikat.   &gt; Więcej informacji: &gt; - [Pobranie danych do wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego) &gt; - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#3-przygotowanie-csr-certificate-signing-request)
     * @return CertificateEnrollmentDataResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesEnrollmentsDataGet() : CertificateEnrollmentDataResponse {
        val localVarResponse = apiV2CertificatesEnrollmentsDataGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateEnrollmentDataResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pobranie danych do wniosku certyfikacyjnego
     * Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.  Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują podmiot, który składa wniosek o certyfikat.   &gt; Więcej informacji: &gt; - [Pobranie danych do wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego) &gt; - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#3-przygotowanie-csr-certificate-signing-request)
     * @return ApiResponse<CertificateEnrollmentDataResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesEnrollmentsDataGetWithHttpInfo() : ApiResponse<CertificateEnrollmentDataResponse?> {
        val localVariableConfig = apiV2CertificatesEnrollmentsDataGetRequestConfig()

        return request<Unit, CertificateEnrollmentDataResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesEnrollmentsDataGet
     *
     * @return RequestConfig
     */
    fun apiV2CertificatesEnrollmentsDataGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/certificates/enrollments/data",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Wysyłka wniosku certyfikacyjnego
     * Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.  Dozwolone typy kluczy prywatnych: - RSA (OID: 1.2.840.113549.1.1.1), długość klucza równa 2048 bitów, - EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), krzywa NIST P-256 (secp256r1)  Zalecane jest stosowanie kluczy EC.  Dozwolone algorytmy podpisu: - RSA PKCS#1 v1.5, - RSA PSS, - ECDSA (format podpisu zgodny z RFC 3279)  Dozwolone funkcje skrótu użyte do podpisu CSR: - SHA1, - SHA256, - SHA384, - SHA512  &gt; Więcej informacji: &gt; - [Wysłanie wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego)
     * @param enrollCertificateRequest  (optional)
     * @return EnrollCertificateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesEnrollmentsPost(enrollCertificateRequest: EnrollCertificateRequest? = null) : EnrollCertificateResponse {
        val localVarResponse = apiV2CertificatesEnrollmentsPostWithHttpInfo(enrollCertificateRequest = enrollCertificateRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnrollCertificateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Wysyłka wniosku certyfikacyjnego
     * Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.  Dozwolone typy kluczy prywatnych: - RSA (OID: 1.2.840.113549.1.1.1), długość klucza równa 2048 bitów, - EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), krzywa NIST P-256 (secp256r1)  Zalecane jest stosowanie kluczy EC.  Dozwolone algorytmy podpisu: - RSA PKCS#1 v1.5, - RSA PSS, - ECDSA (format podpisu zgodny z RFC 3279)  Dozwolone funkcje skrótu użyte do podpisu CSR: - SHA1, - SHA256, - SHA384, - SHA512  &gt; Więcej informacji: &gt; - [Wysłanie wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego)
     * @param enrollCertificateRequest  (optional)
     * @return ApiResponse<EnrollCertificateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesEnrollmentsPostWithHttpInfo(enrollCertificateRequest: EnrollCertificateRequest?) : ApiResponse<EnrollCertificateResponse?> {
        val localVariableConfig = apiV2CertificatesEnrollmentsPostRequestConfig(enrollCertificateRequest = enrollCertificateRequest)

        return request<EnrollCertificateRequest, EnrollCertificateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesEnrollmentsPost
     *
     * @param enrollCertificateRequest  (optional)
     * @return RequestConfig
     */
    fun apiV2CertificatesEnrollmentsPostRequestConfig(enrollCertificateRequest: EnrollCertificateRequest?) : RequestConfig<EnrollCertificateRequest> {
        val localVariableBody = enrollCertificateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/certificates/enrollments",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Pobranie statusu przetwarzania wniosku certyfikacyjnego
     * Zwraca informacje o statusie wniosku certyfikacyjnego.
     * @param referenceNumber Numer referencyjny wniosku certyfikacyjnego
     * @return CertificateEnrollmentStatusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesEnrollmentsReferenceNumberGet(referenceNumber: kotlin.String) : CertificateEnrollmentStatusResponse {
        val localVarResponse = apiV2CertificatesEnrollmentsReferenceNumberGetWithHttpInfo(referenceNumber = referenceNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateEnrollmentStatusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pobranie statusu przetwarzania wniosku certyfikacyjnego
     * Zwraca informacje o statusie wniosku certyfikacyjnego.
     * @param referenceNumber Numer referencyjny wniosku certyfikacyjnego
     * @return ApiResponse<CertificateEnrollmentStatusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesEnrollmentsReferenceNumberGetWithHttpInfo(referenceNumber: kotlin.String) : ApiResponse<CertificateEnrollmentStatusResponse?> {
        val localVariableConfig = apiV2CertificatesEnrollmentsReferenceNumberGetRequestConfig(referenceNumber = referenceNumber)

        return request<Unit, CertificateEnrollmentStatusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesEnrollmentsReferenceNumberGet
     *
     * @param referenceNumber Numer referencyjny wniosku certyfikacyjnego
     * @return RequestConfig
     */
    fun apiV2CertificatesEnrollmentsReferenceNumberGetRequestConfig(referenceNumber: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/certificates/enrollments/{referenceNumber}".replace("{"+"referenceNumber"+"}", encodeURIComponent(referenceNumber.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Pobranie danych o limitach certyfikatów
     * Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o certyfikat KSeF.
     * @return CertificateLimitsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesLimitsGet() : CertificateLimitsResponse {
        val localVarResponse = apiV2CertificatesLimitsGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateLimitsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pobranie danych o limitach certyfikatów
     * Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o certyfikat KSeF.
     * @return ApiResponse<CertificateLimitsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesLimitsGetWithHttpInfo() : ApiResponse<CertificateLimitsResponse?> {
        val localVariableConfig = apiV2CertificatesLimitsGetRequestConfig()

        return request<Unit, CertificateLimitsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesLimitsGet
     *
     * @return RequestConfig
     */
    fun apiV2CertificatesLimitsGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/certificates/limits",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Pobranie listy metadanych certyfikatów
     * Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania. W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
     * @param pageSize Rozmiar strony wyników (optional, default to 10)
     * @param pageOffset Numer strony wyników (optional, default to 0)
     * @param queryCertificatesRequest Kryteria filtrowania (optional)
     * @return QueryCertificatesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesQueryPost(pageSize: kotlin.Int? = 10, pageOffset: kotlin.Int? = 0, queryCertificatesRequest: QueryCertificatesRequest? = null) : QueryCertificatesResponse {
        val localVarResponse = apiV2CertificatesQueryPostWithHttpInfo(pageSize = pageSize, pageOffset = pageOffset, queryCertificatesRequest = queryCertificatesRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueryCertificatesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pobranie listy metadanych certyfikatów
     * Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania. W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
     * @param pageSize Rozmiar strony wyników (optional, default to 10)
     * @param pageOffset Numer strony wyników (optional, default to 0)
     * @param queryCertificatesRequest Kryteria filtrowania (optional)
     * @return ApiResponse<QueryCertificatesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesQueryPostWithHttpInfo(pageSize: kotlin.Int?, pageOffset: kotlin.Int?, queryCertificatesRequest: QueryCertificatesRequest?) : ApiResponse<QueryCertificatesResponse?> {
        val localVariableConfig = apiV2CertificatesQueryPostRequestConfig(pageSize = pageSize, pageOffset = pageOffset, queryCertificatesRequest = queryCertificatesRequest)

        return request<QueryCertificatesRequest, QueryCertificatesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesQueryPost
     *
     * @param pageSize Rozmiar strony wyników (optional, default to 10)
     * @param pageOffset Numer strony wyników (optional, default to 0)
     * @param queryCertificatesRequest Kryteria filtrowania (optional)
     * @return RequestConfig
     */
    fun apiV2CertificatesQueryPostRequestConfig(pageSize: kotlin.Int?, pageOffset: kotlin.Int?, queryCertificatesRequest: QueryCertificatesRequest?) : RequestConfig<QueryCertificatesRequest> {
        val localVariableBody = queryCertificatesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (pageOffset != null) {
                    put("pageOffset", listOf(pageOffset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/certificates/query",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Pobranie certyfikatu lub listy certyfikatów
     * Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
     * @param retrieveCertificatesRequest  (optional)
     * @return RetrieveCertificatesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiV2CertificatesRetrievePost(retrieveCertificatesRequest: RetrieveCertificatesRequest? = null) : RetrieveCertificatesResponse {
        val localVarResponse = apiV2CertificatesRetrievePostWithHttpInfo(retrieveCertificatesRequest = retrieveCertificatesRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetrieveCertificatesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pobranie certyfikatu lub listy certyfikatów
     * Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
     * @param retrieveCertificatesRequest  (optional)
     * @return ApiResponse<RetrieveCertificatesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiV2CertificatesRetrievePostWithHttpInfo(retrieveCertificatesRequest: RetrieveCertificatesRequest?) : ApiResponse<RetrieveCertificatesResponse?> {
        val localVariableConfig = apiV2CertificatesRetrievePostRequestConfig(retrieveCertificatesRequest = retrieveCertificatesRequest)

        return request<RetrieveCertificatesRequest, RetrieveCertificatesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiV2CertificatesRetrievePost
     *
     * @param retrieveCertificatesRequest  (optional)
     * @return RequestConfig
     */
    fun apiV2CertificatesRetrievePostRequestConfig(retrieveCertificatesRequest: RetrieveCertificatesRequest?) : RequestConfig<RetrieveCertificatesRequest> {
        val localVariableBody = retrieveCertificatesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/certificates/retrieve",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
